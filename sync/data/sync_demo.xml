<?xml version="1.0" encoding="UTF-8"?>
<!-- Copyright 2020 Ivan Yelizariev <https://it-projects.info/team/yelizariev>
     License MIT (https://opensource.org/licenses/MIT). -->
<odoo>
    <!-- Telegram -->
    <record id="telegram_project" model="sync.project">
        <field name="name">Demo Telegram Integration</field>
        <field name="network_access" eval="True"/>
        <field name="secret_code">
from odoo.tools import html2plaintext
from lxml.html import clean

# https://github.com/python-telegram-bot/python-telegram-bot
from telegram import Bot as _Bot, Update
_bot = None
if secrets.TELEGRAM_BOT_TOKEN:
    _bot = _Bot(token=secrets.TELEGRAM_BOT_TOKEN)
else:
    raise Exception("bot token is not set")

def sendMessage(chat_id, *args, **kwargs):
    log_transmission("%s@telegram" % chat_id, json.dumps([args, kwargs]))
    _bot.sendMessage(chat_id, *args, **kwargs)

        </field>
        <field name="common_code">
def user2name(user):
    if user.get('username'):
        return '@%s' % (user.get('username'))

    name = user.get('first_name')
    if user.get('last_name'):
        name += ' %s' % user.get('last_name')

    return name

def html_sanitize_telegram(html):
    allowed_tags = frozenset({"b", "i", "u", "s", "a", "code", "pre"})
    cleaner = clean.Cleaner(safe_attrs_only=True, safe_attrs=frozenset(), allow_tags=allowed_tags)
    html = cleaner.clean_html(html)
    return html

        </field>
    </record>

    <record id="telegram_project_param_welcome" model="sync.project.param">
        <field name="key">TELEGRAM_WELCOME_MESSAGE</field>
        <field name="value">Hello! How can I help you?</field>
        <field name="description">Message that is sent to a user on first bot usage</field>
        <field name="project_id" ref="sync.telegram_project"/>
    </record>

    <record id="telegram_project_param_message_sent" model="sync.project.param">
        <field name="key">TELEGRAM_MESSAGE_SENT</field>
        <field name="value">The message has sent in telegram:</field>
        <field name="description">When Odoo Bot reports on successfully sent telegram message</field>
        <field name="project_id" ref="sync.telegram_project"/>
    </record>

    <record id="telegram_project_param_prefix" model="sync.project.param">
        <field name="key">PARTNER_NAME_PREFIX</field>
        <field name="value">Telegram: </field>
        <field name="description">Prefix for new partner name</field>
        <field name="project_id" ref="sync.telegram_project"/>
    </record>

    <record id="telegram_project_secret" model="sync.project.secret">
        <field name="key">TELEGRAM_BOT_TOKEN</field>
        <field name="description">Authentication token provided by https://t.me/BotFather</field>
        <field name="project_id" ref="sync.telegram_project"/>
    </record>

    <!-- telegram: task setup -->
    <record id="telegram_task_setup" model="sync.task">
        <field name="name">Setup</field>
        <field name="project_id" ref="sync.telegram_project"/>
        <field name="code">
def handle_button():
    bot.setWebhook(webhooks.TELEGRAM, allowed_updates=["message", "edited_message"])
        </field>
    </record>

    <record id="telegram_trigger_button" model="sync.trigger.button">
        <field name="name">Setup Webhook</field>
        <field name="sync_task_id" ref="sync.telegram_task_setup"/>
        <field name="trigger_name">TELEGRAM</field>
    </record>

    <!-- telegram: task main -->
    <record id="telegram_task_main" model="sync.task">
        <field name="name">Handle Messages</field>
        <field name="project_id" ref="sync.telegram_project"/>
        <field name="code">
def handle_webhook(httprequest):
    telegram_payload = httprequest.form
    update = Update.de_json(telegram_payload, bot)
    message = update.message or update.edited_message
    is_edit = bool(update.edited_message)
    user_ref = "%s@telegram" % message.user.id
    partner = env["res.partner"].search([("ref", "=", user_ref)])
    if not partner:
        name = "%s%s" % (params.PARTNER_NAME_PREFIX, user2name(message.user))
        partner = env["res.partner"].create({"name": name, "ref": user_ref})

    odoo_message_text = "From Telegram:"

    if message.text == "/start":
        sendMessage(message.chat.id, params.TELEGRAM_WELCOME_MESSAGE)
    elif is_edit:
        odoo_message_text = "Contact has updated his message:"

    odoo_message_text = "%s\n\n%s" % (odoo_message_text, message.text)

    partner.message_post(body=odoo_message_text)


def handle_db(records):
    # records are instances of mail.message
    for r in records:
        if not html2plaintext(r.body or "").startswith("/telegram"):
            continue
        partner = env["res.partner"].browse(r.res_id)
        user_ref = partner.ref or ""
        if not user_ref.endswith("@telegram"):
            continue
        telegram_user_id = user_ref.split("@telegram")[0]
        telegram_message_html = html_sanitize_telegram(r.body)
        telegram_message_html = telegram_message_html.replace("/telegram", "")
        sendMessage(telegram_user_id, telegram_message_html)

        odoo_message_text = "%s:\n\n%s" % (params.TELEGRAM_MESSAGE_SENT, telegram_message_html)
        partner.message_post(body=odoo_message_text)

        </field>
    </record>

    <record id="telegram_trigger_webhook" model="sync.trigger.webhook">
        <field name="name">Telegram updates</field>
        <field name="sync_task_id" ref="sync.telegram_task_main"/>
        <field name="trigger_name">TELEGRAM</field>
    </record>

    <record id="telegram_trigger_automation" model="sync.trigger.automation">
        <field name="name">On new message posted</field>
        <field name="sync_task_id" ref="sync.telegram_task"/>
        <field name="model_id" ref="mail.model_mail_message"/>
        <field name="trigger">on_create</field>
        <field name="filter_domain">[["model","=","res.partner"],["body","ilike","/telegram"]]</field>
    </record>

    <!-- Odoo2odoo -->
    <record id="odoo2odoo_project" model="sync.project">
        <field name="name">Demo Odoo2odoo Integration</field>
        <field name="network_access" eval="True"/>
        <field name="secret_code">
import xmlrpc.client as _client

if not all([params.URL, params.DB, secrets.USERNAME, secrets.PASSWORD]):
    raise Exception("External Odoo Credentials are not set")

def odoo_execute_kw(model, method, *args, **kwargs):
    log_transmission("%s::%s" % (params.URL, params.DB), json.dumps([method, args, kwargs]))
    common = _client.ServerProxy('{}/xmlrpc/2/common'.format(params.URL))
    uid = common.authenticate(db, secrets.USERNAME, secrets.PASSWORD, {})
    models = xmlrpc.client.ServerProxy('{}/xmlrpc/2/object'.format(params.URL))
    res = models.execute_kw(params.DB, uid, secrets.PASSWORD, model, method, args, kwargs)
    log("Response: %s" % res, level="debug")
    return res
        </field>
        <field name="common_code">
PARTNER_REL = "odoo2odoo_partner"
IMAGE_FIELD = "image"
def partner2vals(partner):
    FIELDS = ["name", IMAGE_FIELD]
    res = {}
    for f in FIELDS:
        res[f] = getattr(partner, f)
    return res

def parse_date(s):
    raise NotImplementedError(s)

        </field>
    </record>

    <record id="odoo2odoo_project_param_prefix" model="sync.project.param">
        <field name="key">UPLOAD_ALL_PARTNER_PREFIX</field>
        <field name="value">Sync Studio: </field>
        <field name="project_id" ref="sync.odoo2odoo_project"/>
    </record>

    <record id="odoo2odoo_project_param_url" model="sync.project.param">
        <field name="key">URL</field>
        <field name="description">URL to external Odoo, e.g. https://odoo.example</field>
        <field name="project_id" ref="sync.odoo2odoo_project"/>
    </record>

    <record id="odoo2odoo_project_param_DB" model="sync.project.param">
        <field name="key">DB</field>
        <field name="description">Odoo database name</field>
        <field name="project_id" ref="sync.odoo2odoo_project"/>
    </record>

    <record id="odoo2odoo_project_secret_username" model="sync.project.param">
        <field name="key">USERNAME</field>
        <field name="description">e.g. admin</field>
        <field name="project_id" ref="sync.odoo2odoo_project"/>
    </record>

    <record id="odoo2odoo_project_secret_password" model="sync.project.param">
        <field name="key">PASSWORD</field>
        <field name="project_id" ref="sync.odoo2odoo_project"/>
    </record>

    <record id="odoo2odoo_task" model="sync.task">
        <field name="name">Sync Partners</field>
        <field name="project_id" ref="sync.odoo2odoo_project"/>
        <field name="code">
<![CDATA[
def create_external_partners(partners, name_prefix=""):
    for partner in partners:
        vals = partner2vals(partner)
        vals["name"] = name_prefix + vals["name"]
        external_partner_id = odoo_execute_kw("res.partner", "create", vals)
        date_update = odoo_execute_kw("res.partner", "read", [external_partner_id], fields=["create_date"])
        partner.set_link(PARTNER_REL, external_partner_id, date_update)

def handle_db(records):
    # records are instances of created res.partner
    create_external_partners(records)

def handle_cron(records):
    links = search_links(PARTNER_REL)
    if not links:
        log("Cron: there are no associated partners")
        return
    external_partners = odoo_execute_kw(
        "res.partner",
        "search_read",
        [["id", "in", links.external], ["write_date", ">", links.sync_date]],
        fields=["write_date", IMAGE_FIELD]
    )
    for ep in external_partners:
        link = get_link(PARTNER,  ep["id"])
        p = link.odoo
        if parse_date(ep["write_date"]) > link.sync_date:
            p.write({IMAGE_FIELD: ep[IMAGE_FIELD]})
            link.update(date_update)

def handle_button():
    chunk = None
    CHUNK_SIZE = 10
    for r in env["res.partner"].search([]):
        # check that record is not created yet
        link = r.get_link(PARTNER_REL)
        if link:
            # object already exists
            continue

        if not chunk:
            chunk = r
        else:
            chunk |= r
        if len(chunk) == CHUNK_SIZE:
            async(create_external_partner)(chunk, name_prefix=params.UPLOAD_ALL_PARTNER_PREFIX)
            chunk = None
]]>
        </field>
    </record>

    <record id="odoo2odoo_trigger_automation" model="sync.trigger.automation">
        <field name="name">On partner created</field>
        <field name="sync_task_id" ref="sync.odoo2odoo_task"/>
        <field name="model_id" ref="base.model_res_partner"/>
        <field name="trigger">on_create</field>
    </record>

    <record id="odoo2odoo_trigger_cron" model="sync.trigger.cron">
        <field name="sync_task_id" ref="sync.odoo2odoo_task"/>
        <field name="interval_number">15</field>
        <field name="interval_type">minute</field>
    </record>

    <record id="odoo2odoo_trigger_button" model="sync.trigger.button">
        <field name="name">Sync All Partners</field>
        <field name="sync_task_id" ref="sync.odoo2odoo_task"/>
        <field name="trigger_name">SYNC_ALL</field>
    </record>


    <!-- Trello-Github -->
    <record id="trello-github_project" model="sync.project">
        <field name="name">Demo Trello-Github Integration</field>
        <field name="network_access" eval="True"/>
        <field name="secret_code">
<![CDATA[
# consts
GITHUB="github"
TRELLO="trello"

from github import Github as _Github
if not secrets.GITHUB_TOKEN:
    raise Exception("bot token is not set")
if not secrets.GITHUB_REPO:
    raise Exception("github repo is not set")

_g = _Github(secrets.GITHUB_TOKEN)
_grepo = _g.get_repo(secrets.GITHUB_REPO)

# Trello cards
def trello_card_create(name, issue_id):
    log_transmission(TRELLO, "create: %s" % name)
    return card_id

def trello_card_add_labels(card_id, tlabel_ids):
    log_transmission(TRELLO, "add labels to card#%s: %s" % (card_id, tlabel_ids))
    pass

def trello_card_remove_labels(card_id, tlabel_ids):
    log_transmission(TRELLO, "remove labels from card#%s: %s" % (card_id, tlabel_ids))
    pass

def trello_card_add_message(card_id, message):
    log_transmission(TRELLO, "add message to card#%s: %s" % (card_id, message))
    pass

# Trello labels
def trello_label_create(name):
    log_transmission(TRELLO, "create label: %s" % (name))
    return label_id

def trello_label_delete(tlabel_id):
    log_transmission(TRELLO, "delete label: %s" % (tlabel_id))
    pass

def trello_label_update(tlabel_id, new_name):
    log_transmission(TRELLO, "label#%s update: %s" % (tlabel_id, new_name))
    pass

# Github webhooks

def github_set_webhook(url, events):
    # API: https://docs.github.com/en/rest/reference/repos#create-a-repository-webhook
    # Events: https://docs.github.com/en/developers/webhooks-and-events/webhook-events-and-payloads
    config = {"url": url}
    _grepo.create_hook("web", config, events)

# Github issues
def github_issue_add_labels(issue_id, glabel_ids):
    pass

def github_issue_remove_labels(issue_id, glabel_ids):
    pass

# Github labels
def github_label_create(name):
    return glabel_id

def github_label_delete(glabel_id):
    pass

def github_label_update(glabel_id, new_name):
    pass
]]>
        </field>
        <field name="common_code">
<![CDATA[
ISSUES_REL="TRELLO_GITHUB_ISSUES_REL"
LABELS_REL="TRELLO_GITHUB_LABELS_REL"

def get_related_label(from_id, name, from, to)
    elink = get_link(LABELS_REL, [(from, from_id), (to, None)])

    if elink:
        return elink.get(to)
    else:
        to_id = github_label_create(name) if to == GITHUB else trello_label_create(name)
        elink = set_link(LABELS_REL, [(from, from_id), (to, to_id)])
        return to_id

def github2trello_labels(labels)
    tlabel_ids = []
    for lb in labels:
        label_id = lb["id"]
        label_name = lb["name"]
        tlabel_id = get_related_label(label_id, label_name, from=GITHUB, to=TRELLO)
        tlabel_ids.append(tlabel_id)
    return tlabel_ids

]]>
        </field>
    </record>

    <record id="trello-github_project_secret_github_token" model="sync.project.secret">
        <field name="key">GITHUB_TOKEN</field>
        <field name="description">Token with access to read issues and create webhooks. See https://docs.github.com/en/github/authenticating-to-github/creating-a-personal-access-token</field>
        <field name="project_id" ref="sync.trello-github_project"/>
    </record>

    <record id="trello-github_project_secret_github_repo" model="sync.project.secret">
        <field name="key">GITHUB_REPO</field>
        <field name="description">owner/repo_name</field>
        <field name="project_id" ref="sync.trello-github_project"/>
    </record>

    <record id="trello-github_project_param_prefix_name" model="sync.project.param">
        <field name="key">ISSUE_FROM_GITHUB_PREFIX</field>
        <field name="value">GITHUB: </field>
        <field name="project_id" ref="sync.trello-github_project"/>
    </record>

    <record id="trello-github_project_param_prefix_message" model="sync.project.param">
        <field name="key">MESSAGE_PREFIX</field>
        <field name="value">A Message posted on GitHub: </field>
        <field name="project_id" ref="sync.trello-github_project"/>
    </record>

    <record id="trello-github_project_param_labels_merge_strategy" model="sync.project.param">
        <field name="key">LABELS_MERGE_STRATEGY</field>
        <field name="description">Possible values:
USE_TRELLO, USE_GITHUB: use version from one side and override values from another
UNION: add missed labels to each side
INTERSECTION: remove labes that are not attached on another side
        </field>
        <field name="project_id" ref="sync.trello-github_project"/>
    </record>

    <record id="trello-github_task_setup" model="sync.task">
        <field name="name">Setup</field>
        <field name="project_id" ref="sync.trello-github_project"/>
        <field name="code">
<![CDATA[
def handle_button():
    if TRIGGER_NAME == "SETUP_GITHUB":
        github_set_webhook(webhooks.GITHUB_ISSUE_UPDATES, ["issues"])
        github_set_webhook(webhooks.GITHUB_LABEL_UPDATES, ["label"])
    elif TRIGGER_NAME == "SETUP_TRELLO":
        TODO
    else:
        raise Exception("Unknown button event: %s" % TRIGGER_NAME)
]]>
        </field>
    </record>
    <record id="trello-github_task_setup_trigger_button_github" model="sync.trigger.button">
        <field name="name">Setup Github Webhook</field>
        <field name="sync_task_id" ref="sync.trello-github_task_setup"/>
        <field name="trigger_name">SETUP_GITHUB</field>
    </record>
    <record id="trello-github_task_setup_trigger_button_trello" model="sync.trigger.button">
        <field name="name">Setup Trello Webhook</field>
        <field name="sync_task_id" ref="sync.trello-github_task_setup"/>
        <field name="trigger_name">SETUP_TRELLO</field>
    </record>

    <record id="trello-github_task_issues" model="sync.task">
        <field name="name">Sync Github Issues to Trello (name, messages, labels)</field>
        <field name="project_id" ref="sync.trello-github_project"/>
        <field name="code">
<![CDATA[
def handle_webhook(httprequest):
    issue_id = TODO
    issue_name = TODO
    elink = get_link(ISSUES_REL, [(GITHUB, issue_id), (TRELLO, None)])
    if not elink:
        card_id = trello_card_create(issue_name, issue_id)
        elink = set_link(ISSUES_REL, [(GITHUB, issue_id), (TRELLO, card_id)])

    issue_message = TODO
    if issue_message:
        message = "%s%s" % (params.MESSAGE_PREFIX, issue_message)
        trello_card_add_message(elink.get(TRELLO), message)

    # attached labels:
    labels = TODO
    tlabel_ids = github2trello_labels(labels)

    if tlabel_ids:
        trello_card_add_labels(elink.get(TRELLO), tlabel_ids)

    # detached labels:
    labels = TODO
    tlabel_ids = github2trello_labels(labels)

    if tlabel_ids:
        trello_card_remove_labels(elink.get(TRELLO), tlabel_ids)

def handle_button():
    # Sync all existing open github issues to trello
    fetch_github_issues()

def fetch_github_issues(page=0):
    CHUNK_SIZE=10
    # fetch page
    TODO
    if not issues:
        return
    # split issues into chunks
    for TODO in TODO:
        chunk = TODO
        async(process_github_issues)(chunk)
    # fetch next page
    async(fetch_github_issues)(page+1)

def process_github_issues():
    # Should be similar to process a single issue (see handle_webhook)
    TODO

]]>
        </field>
    </record>

    <record id="trello-github_task_issues_trigger_webhook_github" model="sync.trigger.webhook">
        <field name="name">Github Issue updates</field>
        <field name="sync_task_id" ref="sync.trello-github_task_issues"/>
        <field name="trigger_name">GITHUB_ISSUE_UPDATES</field>
    </record>

    <record id="trello-github_task_cards" model="sync.task">
        <field name="name">Sync Trello Cards to Github (labels)</field>
        <field name="project_id" ref="sync.trello-github_project"/>
        <field name="code">
<![CDATA[
def handle_webhook(httprequest):
    # Code is similar to github to trello sync
    pass
]]>
        </field>
    </record>

    <record id="trello-github_task_issues_trigger_webhook_trello" model="sync.trigger.webhook">
        <field name="name">Trello Card updates</field>
        <field name="sync_task_id" ref="sync.trello-github_task_cards"/>
        <field name="trigger_name">TRELLO_CARD_UPDATES</field>
    </record>

    <record id="trello-github_task_labels" model="sync.task">
        <field name="name">Sync labels Updating/Deleting</field>
        <field name="project_id" ref="sync.trello-github_project"/>
        <field name="code">
<![CDATA[
def handle_webhook(httprequest):
    glabel_id = None
    tlabel_id = None
    is_updated = None
    is_deleted = None
    if TRIGGER_NAME == "TRELLO_LABEL_UPDATES":
        tlabel_id = TODO
    elif TRIGGER_NAME == "GITHUB_LABEL_UPDATES":
        is_updated = httprequest.form["action"] == "edited"
        is_deleted = httprequest.form["action"] == "deleted
        glabel_id = httprequest.form["label"]["id"]
    else:
       raise Exception("Unknown Event")

    elinks = search_links(LABELS_REL, [(GITHUB, glabel_id), (TRELLO, tlabel_id)])
    if not elinks:
        # label is not linked
        return
    glabel_id = elinks[0].get(GITHUB)
    tlabel_id = elinks[0].get(TRELLO)
    if is_updated:
        if TRIGGER_NAME == "TRELLO_LABEL_UPDATES":
            github_label_update(glabel_id, new_name):
        else:
            trello_label_update(tlabel_id, new_name):

    if is_deleted:
        elinks.unlink()
        if TRIGGER_NAME == "TRELLO_LABEL_UPDATES":
            github_label_delete(glabel_id):
        else:
            trello_label_detele(tlabel_id):

]]>
        </field>
    </record>

    <record id="trello-github_task_labels_trigger_webhook_trello" model="sync.trigger.webhook">
        <field name="name">Trello Label updates</field>
        <field name="sync_task_id" ref="sync.trello-github_task_labels"/>
        <field name="trigger_name">TRELLO_LABEL_UPDATES</field>
    </record>

    <record id="trello-github_task_labels_trigger_webhook_github" model="sync.trigger.webhook">
        <field name="name">Github Label updates</field>
        <field name="sync_task_id" ref="sync.trello-github_task_labels"/>
        <field name="trigger_name">GITHUB_LABEL_UPDATES</field>
    </record>

    <record id="trello-github_task_conflicts_resolving" model="sync.task">
        <field name="name">Labels Conflict Resolving</field>
        <field name="project_id" ref="sync.trello-github_project"/>
        <field name="code">
<![CDATA[
def handle_cron():
    elinks = search_links(ISSUES_REL, [(GITHUB, None), (TRELLO, None)])
    issue_ids = elinks.get(GITHUB)
    # https://docs.github.com/en/rest/reference/issues#list-repository-issues
    # issue is {id: int, labels: [{id: int, name: str, ...}]}
    issues = TODO
    # issue_id -> issue
    issues_index = TODO

    card_ids = elinks.get(TRELLO)
    # https://developer.atlassian.com/cloud/trello/rest/api-group-boards/#api-boards-id-cards-get
    # https://developer.atlassian.com/cloud/trello/rest/api-group-cards/#api-cards-id-get
    # card is dict {id: int, idLabels: [int], ...}
    cards = TODO
    # card_id -> card
    cards_index = TODO

    for el in elinks:
        card_id = el.get(TRELLO)
        issue_id = el.get(GITHUB)
        card = cards_index.get(card_id)
        issue = issues_index.get(issue_id)
        if not (card and issue):
            log("Linked card or issue is missed: %s" % (card, issue), level=LOG_WARNING)
            continue
        # compare labels
        tlabel_ids = card.idsLabels
        glabel_ids = [lbl["id"] for lbl in issue["labels"]]
        tlinks = search_links(LABELS_REL, [(GITHUB, None), (TRELLO, tlabel_ids)])
        glinks = search_links(LABELS_REL, [(GITHUB, glabel_ids), (TRELLO, None)])
        if tlinks == glinks:
            # all fine
        logs("Found labels mismatch: issue=%s, card=%s" % (issue["id"], card["id"]), level=LOG_DEBUG)

        tlinks_add = None
        tlinks_remove = None
        glinks_add = None
        glinks_remove = None
        if LABELS_MERGE_STRATEGY == "USE_TRELLO":
            glinks_add = tlinks - glinks
            glinks_remove = glinks - tlinks
        elif LABELS_MERGE_STRATEGY == "USE_GITHUB":
            tlinks_add = glinks - tlinks
            tlinks_remove = tlinks - glinks
        elif LABELS_MERGE_STRATEGY == "UNION":
            tlinks_add = glinks - tlinks
            glinks_add = tlinks - glinks
        elif LABELS_MERGE_STRATEGY == "INTERSECTION":
            tlinks_remove = tlinks - glinks
            glinks_remove = glinks - tlinks
        else:
            raise Exception("Unknown LABELS_MERGE_STRATEGY: %s" % LABELS_MERGE_STRATEGY, level=LOG_ERROR)

        if tlinks_add:
            trello_card_add_labels(card_id, tlinks_add.get(TRELLO))
        if glinks_add:
            github_issue_add_labels(card_id, glinks_add.get(GITHUB))
        if tlinks_remove:
            trello_card_remove_labels(card_id, tlinks_remove.get(TRELLO))
        if glinks_remove:
            github_issue_remove_labels(card_id, glinks_remove.get(GITHUB))

]]>
        </field>
    </record>

    <record id="trello-github_task_conflicts_resolving_cron" model="sync.trigger.cron">
        <field name="trigger_name">CONFLICT_RESOLVING</field>
        <field name="sync_task_id" ref="sync.trello-github_task_conflicts_resovling"/>
        <field name="interval_number">1</field>
        <field name="interval_type">day</field>
    </record>

    <!-- unittest -->
    <record id="test_project" model="sync.project">
        <field name="name">Project For Unittests</field>
        <!-- disable to hide from UI -->
        <field name="active" eval="False" />
    </record>

    <record id="test_project_param" model="sync.project.param">
        <field name="key">PARTNER_RELATION</field>
        <field name="value">sync_unittest_partner</field>
        <field name="project_id" ref="sync.test_project"/>
    </record>

    <record id="test_task" model="sync.task">
        <field name="name">Assign ref to new partners</field>
        <field name="project_id" ref="sync.test_project"/>
        <field name="code">
def handle_db(records):
    for r in records:
        r.set_link(PARTNER_RELATION, r.id)
        </field>
    </record>

    <record id="test_trigger_automation" model="sync.trigger.automation">
        <field name="name">Sync test: Run code On partner created</field>
        <field name="sync_task_id" ref="sync.test_task"/>
        <field name="model_id" ref="base.model_res_partner"/>
        <field name="trigger">on_create</field>
    </record>
</odoo>
